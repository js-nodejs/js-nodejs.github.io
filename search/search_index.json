{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <p>i'm using python venv can i replace with pipenv</p> <p>Yes, you can replace Python's built-in venv with Pipenv if you'd like. Here's a comparison of both and how you can transition:</p>"},{"location":"#venv-vs-pipenv","title":"<code>venv</code> vs. <code>Pipenv</code>","text":"<ol> <li> <p><code>venv</code>:</p> <ul> <li> <p><code>venv</code> is a built-in tool in Python (since version 3.3) that helps you create isolated environments for your projects.</p> </li> <li> <p>It's lightweight and simple to use, but you need to manage dependencies manually using pip and requirements.txt.</p> </li> </ul> </li> <li> <p><code>Pipenv</code>:</p> <ul> <li> <p><code>Pipenv</code> is a higher-level tool that manages virtual environments and dependencies more efficiently.</p> </li> <li> <p>It automatically creates and manages a virtual environment for your project.</p> </li> <li> <p>It handles both the <code>Pipfile</code> (for dependency management) and <code>Pipfile.lock</code> (for deterministic installs).</p> </li> <li> <p>It also integrates with <code>pip</code> for installing packages, but offers more features like checking for security vulnerabilities in your dependencies.</p> </li> </ul> </li> </ol> Steps to Replace <code>venv</code> with <code>Pipenv</code> <ol> <li> <p>Install Pipenv (if you haven't already):</p> bash<pre><code>\n</code></pre> </li> <li> <p>Remove the current <code>venv</code> (if you already have one):</p> <ul> <li>Simply delete the <code>venv</code> folder from your project directory.</li> </ul> </li> <li> <p>Create a new Pipenv environment: Navigate to your project directory, and then run:</p> bash<pre><code>pipenv install\n</code></pre> <p>This will create a new virtual environment and also generate a <code>Pipfile</code> if it doesn't already exist.</p> </li> <li> <p>Install dependencies:</p> <ul> <li> <p>If you want to install dependencies, just use:</p> bash<pre><code>pipenv install &lt;package-name&gt;\n</code></pre> <p>This will install the package and update your <code>Pipfile</code> and <code>Pipfile.lock</code>.</p> </li> </ul> </li> <li> <p>Activate the virtual environment: To activate the virtual environment created by Pipenv:</p> bash<pre><code>pipenv shell\n</code></pre> </li> <li> <p>To install dependencies from a <code>Pipfile.lock</code> (if you have one):</p> bash<pre><code>pipenv install --dev  # If it's a development dependency or just 'pipenv install'\n</code></pre> </li> </ol> Notes: <ul> <li> <p>If you were using <code>requirements.txt</code> previously, you can still generate one from <code>Pipenv</code> with:</p> bash<pre><code>pipenv lock -r &gt; requirements.txt\n</code></pre> </li> <li> <p>When using <code>Pipenv</code>, it will automatically create a virtual environment in the background, so you don't need to explicitly manage the virtual environment like you do with <code>venv</code>.</p> </li> </ul> <p>Pipenv gives you a more streamlined experience for handling both virtual environments and dependencies. It's useful for teams or larger projects where dependency management and consistency are crucial.</p>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2025/03/30/understanding-cors-configurations-in-nodejs/","title":"Understanding CORS Configurations in Node.js","text":"<p>Cross-Origin Resource Sharing (CORS) is a mechanism that allows servers to specify who can access their resources from different origins. In this blog post, we'll explore why one CORS configuration works while another doesn't in a Node.js environment. ...</p>"},{"location":"blog/2025/03/30/understanding-cors-configurations-in-nodejs/#cors-configuration-explained","title":"CORS Configuration Explained","text":"<p>In a Node.js application, we use the <code>cors</code> middleware to handle CORS. Here are two common ways to configure it:</p>"},{"location":"blog/2025/03/30/understanding-cors-configurations-in-nodejs/#1-cors-configuration-that-works","title":"1. CORS Configuration That Works","text":"<pre><code>const corsOptions = {\n  origin: \"*\", // Allow all origins\n  methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"], // Allow specific methods\n  allowedHeaders: [\"Content-Type\", \"Authorization\"], // Allow specific headers\n};\n\napp.use(cors(corsOptions));\n</code></pre> Why It Works: <ul> <li> <p><code>origin: '*'</code>: Allows all origins to make requests to the server.</p> </li> <li> <p><code>methods: ['GET', 'POST', 'PUT', 'DELETE']</code>: This allows specific HTTP methods to be used in cross-origin requests. If the frontend needs to make a POST or PUT request, this configuration ensures that these methods are allowed.</p> </li> <li> <p><code>allowedHeaders: ['Content-Type', 'Authorization']</code>: This explicitly allows the <code>Content-Type</code> and <code>Authorization</code> headers in requests. Without this, browsers may reject requests that include custom headers.</p> </li> </ul> <p>This configuration works well for most applications, especially when the frontend needs to interact with the backend using custom methods or headers.</p>"},{"location":"blog/2025/03/30/understanding-cors-configurations-in-nodejs/#2-cors-configuration-that-might-not-work","title":"2. CORS Configuration That Might Not Work","text":"<pre><code>const corsOptions = {\n  origin: \"*\", // Allow all origins\n};\n\napp.use(cors(corsOptions));\n</code></pre> Why It Might Not Work: <ul> <li> <p><code>origin: '*'</code> allows requests from any origin, but that's not enough if the frontend is making requests using methods like POST, PUT, or custom headers like Authorization.</p> </li> <li> <p>Without specifying <code>methods</code> or <code>allowedHeaders</code>, the server may block requests that use these methods or custom headers because they are not explicitly allowed in the CORS configuration.</p> </li> </ul> <p>This configuration is more permissive but lacks the explicit allowance of headers and methods, which may lead to issues when using non-GET requests or custom headers.</p>"},{"location":"blog/2025/03/30/understanding-cors-configurations-in-nodejs/#conclusion","title":"Conclusion","text":"<p>In general, it's a good practice to be explicit with CORS configurations, especially when dealing with methods or custom headers. By specifying which methods and headers are allowed, you ensure that your API can handle a wider range of requests without being blocked by browsers due to CORS restrictions.</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/","title":"Debugging Cors Network Issue","text":"<p>If your Node.js API works in the web browser on your computer but not on the mobile browser, even when both devices are on the same network, let's go through a few more potential solutions and troubleshooting steps to fix this:</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#1-double-check-mobile-devices-network-connection","title":"1. Double-Check Mobile Device\u2019s Network Connection","text":"<p>Ensure that both devices are connected to the same Wi-Fi network. Sometimes, mobile devices may connect to a different network (like a 5G network) while the computer is connected to the local Wi-Fi network.</p> <p>You can verify this by checking the IP address on both devices. On your computer, verify the IP address with <code>ipconfig</code> (Windows) or <code>ifconfig</code> (Linux/macOS). On the mobile device, you can try to <code>ping</code> your computer\u2019s IP address (192.168.1.69) to ensure the network is properly connected.</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#2-confirm-ip-address","title":"2. Confirm IP Address","text":"<p>Since you mentioned that the server works on <code>http://192.168.1.69:3000</code> (in the browser on your computer), confirm that the correct IP address is being used in your mobile browser. Make sure you're using <code>http://192.168.1.69:5000</code> for the API.</p> <ul> <li> <p>If you are accessing <code>http://localhost:5000</code> or <code>http://127.0.0.1:5000</code> from the mobile browser, it won\u2019t work because those addresses refer to the mobile device itself, not the computer running the server.</p> </li> <li> <p>Use <code>http://192.168.1.69:5000/api/records</code> for testing the API from your mobile device.</p> </li> </ul>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#3-firewall-configuration-on-computer-server","title":"3. Firewall Configuration on Computer (Server)","text":"<p>If your server is on a computer and you cannot access it from your mobile device, there might be a firewall blocking external access to port <code>5000</code>. You need to ensure that the firewall is open on your computer for the API server to accept incoming requests from other devices.</p> <p>For Linux (iptables or firewalld):</p> <p>If you're using iptables, allow traffic on port <code>5000</code>:</p> <pre><code>sudo iptables -A INPUT -p tcp --dport 5000 -j ACCEPT\n</code></pre> <p>For firewalld, run:</p> <pre><code>sudo firewall-cmd --zone=public --add-port=5000/tcp --permanent\nsudo firewall-cmd --reload\n</code></pre> <p>For Windows:</p> <ol> <li>Open Windows Defender Firewall.</li> <li>Go to Advanced Settings &gt; Inbound Rules &gt; New Rule.</li> <li>Select Port and allow TCP for port <code>5000</code>.</li> <li>Ensure the rule is enabled.</li> </ol>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#4-cors-settings","title":"4. CORS Settings","text":"<p>Since your web app works on the computer but not on mobile, it could be a CORS issue. However, you\u2019ve already configured CORS using <code>origin: \"*\"</code>, which should be sufficient for all devices, including mobile. But sometimes mobile browsers might behave differently, so let\u2019s double-check:</p> <p>Try setting specific headers to ensure CORS is correctly enabled. You can configure it like this:</p> <pre><code>const corsOptions = {\n  origin: \"*\", // Allow all origins\n  methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"], // Allow specific methods\n  allowedHeaders: [\"Content-Type\", \"Authorization\"], // Allow specific headers\n};\n\napp.use(cors(corsOptions));\n</code></pre>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#5-test-using-curl-or-postman-on-mobile","title":"5. Test Using Curl or Postman on Mobile","text":"<p>Instead of using the browser, you can test the API on your mobile device using Postman or curl to see if the issue is with the mobile browser itself.</p> <p>Using Postman on Mobile:</p> <p>You can install Postman on your mobile device (available for both Android and iOS) and send a request to <code>http://192.168.1.69:5000/api/records</code>. If it works in Postman but not in the browser, it might be a browser-related issue, such as blocking CORS or mixed content.</p> <p>Using curl on Android (or iOS):</p> <p>You can use a terminal emulator app like Termux for Android or iSH Shell for iOS to make an HTTP request:</p> <pre><code>curl http://192.168.1.69:5000/api/records\n</code></pre>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#6-check-for-mixed-content-http-vs-https","title":"6. Check for Mixed Content (HTTP vs HTTPS)","text":"<p>If your mobile device is trying to access the API over HTTPS while your Node.js server is serving over HTTP, some mobile browsers may block the request because it's considered \"mixed content.\"</p> <p>Make sure your mobile browser is making requests to HTTP (not HTTPS) if you're not using SSL for your local development server. This could be a common issue in some mobile browsers, especially if you're using <code>http://</code> on the computer but <code>https://</code> on mobile.</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#7-verify-server-binding-on-0000","title":"7. Verify Server Binding on 0.0.0.0","text":"<p>You've already set the server to bind to <code>0.0.0.0</code>, which should make the server accessible from any device on the network:</p> <pre><code>app.listen(5000, \"0.0.0.0\", () =&gt; {\n  console.log(\"Server running on port 5000\");\n});\n</code></pre> <p>This is correct. It binds the server to all network interfaces, which ensures that requests from other devices (including your mobile device) can access the server.</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#8-mobile-browser-developer-tools","title":"8. Mobile Browser Developer Tools","text":"<p>Sometimes, there could be issues with the mobile browser's settings. You can try clearing the cache or opening the browser's developer tools (if available) to inspect the network requests and see what error is being returned (like a CORS error or network timeout).</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#9-test-api-using-localhost-vs-ip-address","title":"9. Test API Using <code>localhost</code> vs IP Address","text":"<p>If you're running the server on the same device as the browser (for instance, running both the client and server on your computer), <code>localhost:5000</code> will work. But when testing from another device (like your mobile), you need to use the IP address of your server (<code>192.168.1.69:5000</code>), not <code>localhost</code>.</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#10-server-logs","title":"10. Server Logs","text":"<p>Check the server logs to see if there are any requests coming from the mobile device. You can log the requests on the server to verify that it's receiving the API calls.</p> <pre><code>app.use((req, res, next) =&gt; {\n  console.log(`Request from: ${req.ip} for ${req.originalUrl}`);\n  next();\n});\n</code></pre> <p>This will log the incoming requests to your API, which might help diagnose if the mobile device's requests are being received at all.</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#recap","title":"Recap:","text":"<ul> <li>Network: Ensure both devices are on the same network.</li> <li>Firewall: Open port <code>5000</code> on the server machine if using a firewall.</li> <li>CORS: Double-check that CORS is configured correctly.</li> <li>Use correct IP: Make sure you're using <code>192.168.1.69:5000</code> on mobile.</li> <li>Mixed Content: Ensure you're not facing an HTTPS vs HTTP issue.</li> <li>Test with Postman/curl: Test the API using other tools on mobile to rule out browser issues.</li> </ul>"},{"location":"blog/archive/2025/","title":"2025","text":""}]}