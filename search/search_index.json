{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>i'm using python venv can i replace with pipenv</p> <p>Yes, you can replace Python's built-in venv with Pipenv if you'd like. Here's a comparison of both and how you can transition:</p>"},{"location":"#venv-vs-pipenv","title":"<code>venv</code> vs. <code>Pipenv</code>","text":"<ol> <li> <p><code>venv</code>:</p> <ul> <li> <p><code>venv</code> is a built-in tool in Python (since version 3.3) that helps you create isolated environments for your projects.</p> </li> <li> <p>It's lightweight and simple to use, but you need to manage dependencies manually using pip and requirements.txt.</p> </li> </ul> </li> <li> <p><code>Pipenv</code>:</p> <ul> <li> <p><code>Pipenv</code> is a higher-level tool that manages virtual environments and dependencies more efficiently.</p> </li> <li> <p>It automatically creates and manages a virtual environment for your project.</p> </li> <li> <p>It handles both the <code>Pipfile</code> (for dependency management) and <code>Pipfile.lock</code> (for deterministic installs).</p> </li> <li> <p>It also integrates with <code>pip</code> for installing packages, but offers more features like checking for security vulnerabilities in your dependencies.</p> </li> </ul> </li> </ol> Steps to Replace <code>venv</code> with <code>Pipenv</code> <ol> <li> <p>Install Pipenv (if you haven't already):</p> bash<pre><code>\n</code></pre> </li> <li> <p>Remove the current <code>venv</code> (if you already have one):</p> <ul> <li>Simply delete the <code>venv</code> folder from your project directory.</li> </ul> </li> <li> <p>Create a new Pipenv environment: Navigate to your project directory, and then run:</p> bash<pre><code>pipenv install\n</code></pre> <p>This will create a new virtual environment and also generate a <code>Pipfile</code> if it doesn't already exist.</p> </li> <li> <p>Install dependencies:</p> <ul> <li> <p>If you want to install dependencies, just use:</p> bash<pre><code>pipenv install &lt;package-name&gt;\n</code></pre> <p>This will install the package and update your <code>Pipfile</code> and <code>Pipfile.lock</code>.</p> </li> </ul> </li> <li> <p>Activate the virtual environment: To activate the virtual environment created by Pipenv:</p> bash<pre><code>pipenv shell\n</code></pre> </li> <li> <p>To install dependencies from a <code>Pipfile.lock</code> (if you have one):</p> bash<pre><code>pipenv install --dev  # If it's a development dependency or just 'pipenv install'\n</code></pre> </li> </ol> Notes: <ul> <li> <p>If you were using <code>requirements.txt</code> previously, you can still generate one from <code>Pipenv</code> with:</p> bash<pre><code>pipenv lock -r &gt; requirements.txt\n</code></pre> </li> <li> <p>When using <code>Pipenv</code>, it will automatically create a virtual environment in the background, so you don't need to explicitly manage the virtual environment like you do with <code>venv</code>.</p> </li> </ul> <p>Pipenv gives you a more streamlined experience for handling both virtual environments and dependencies. It's useful for teams or larger projects where dependency management and consistency are crucial.</p>"},{"location":"#code-highlight","title":"Code Highlight","text":"javascript<pre><code>useEffect(() =&gt; {\n  signalRService.startConnection();\n  return () =&gt; {\n    signalRService.stopConnection();\n  };\n}, []);\n</code></pre> What does it do? <ul> <li> <p><code>useEffect</code> hook: This React hook is used to run side effects in functional components. The second argument, <code>[]</code>, means that the effect will run once, right after the component is mounted (i.e., when the component is added to the DOM). This is similar to <code>componentDidMount</code> in class components.</p> </li> <li> <p><code>signalRService.startConnection()</code>: This line starts a connection to the SignalR server, which is usually used for real-time communication in web applications (like for receiving real-time updates from a server, such as messages, notifications, etc.).</p> </li> <li> <p>The <code>return</code> statement inside <code>useEffect</code>: The function inside the <code>return</code> is a cleanup function, and it's called when the component is about to unmount or before the effect is re-executed (but in this case, it will only be run once when the component unmounts, since <code>[]</code> is passed as the dependency array).</p> </li> <li> <p><code>signalRService.stopConnection()</code>: This stops the connection to the SignalR server when the component is unmounted. It\u2019s important to stop the connection to prevent memory leaks or unnecessary network traffic when the component is no longer in use.</p> </li> </ul> <p>Does it stop the connection after success?</p> <p>Not exactly. The connection is started when the component is mounted (<code>signalRService.startConnection()</code>), and it will be stopped when the component is unmounted (<code>signalRService.stopConnection()</code>).</p> <p>The connection is not immediately stopped after it's started. It remains active while the component is mounted, and only when the component is about to be unmounted (i.e., removed from the DOM) will the <code>stopConnection</code> function be triggered. This ensures that the SignalR connection is only open while the component is actively in use and will be cleaned up when the component is no longer needed.</p>"},{"location":"#code-hightlight-2","title":"Code Hightlight 2","text":"javascrip<pre><code>const post = await fetch(\"https://jsonplaceholder.typicode.com/posts/1\");\nconsole.log(post);\n</code></pre> Explanation of the Code: <ol> <li> <p><code>fetch()</code>:</p> <ul> <li><code>fetch()</code> is an asynchronous function that makes an HTTP request to the specified URL and returns a <code>Promise</code>. This promise resolves to the <code>Response</code> object, which represents the entire response (headers, status, body, etc.).</li> </ul> </li> <li> <p><code>await</code>:</p> <ul> <li>The <code>await</code> keyword is used to pause the execution of the code until the <code>fetch()</code> promise resolves. This means that the variable <code>post</code> will contain the resolved value of the <code>fetch()</code> promise, which is a <code>Response</code> object.</li> </ul> </li> <li> <p><code>console.log(post)</code>:</p> <ul> <li>The <code>post</code> variable will now hold a <code>Response</code> object, not the actual data (i.e., the content of the post). This <code>Response</code> object contains metadata like the HTTP status, headers, etc.</li> </ul> </li> </ol> <p>What Does <code>console.log(post)</code> Return?</p> <p>The output of <code>console.log(post)</code> will be a <code>Response</code> object that looks something like this:</p> javascript<pre><code>Response {\n  type: \"basic\",\n  url: \"https://jsonplaceholder.typicode.com/posts/1\",\n  redirected: false,\n  status: 200,\n  statusText: \"OK\",\n  headers: Headers {},\n  ok: true,\n  body: ReadableStream {...},\n  bodyUsed: false\n}\n</code></pre> Key Properties of the <code>Response</code> Object: <ul> <li> <p><code>status</code>: The HTTP status code (200 means success).</p> </li> <li> <p><code>statusText</code>: A short description of the status code (e.g., \"OK\" for 200).</p> </li> <li> <p><code>ok</code>: A boolean indicating whether the status code is in the 200-299 range (i.e., successful response).</p> </li> <li> <p><code>url</code>: The URL of the response.</p> </li> <li> <p><code>headers</code>: The headers of the response.</p> </li> <li> <p><code>body</code>: A <code>ReadableStream</code> representing the body of the response (this is not directly readable).</p> </li> </ul> <p>Why is this the result?</p> <p><code>fetch()</code> does not automatically parse the body of the response into JSON or any other format. It simply returns a <code>Response</code> object. To get the actual data (like the post content), you need to call the <code>.json()</code> method (or <code>.text()</code>, <code>.blob()</code>, etc., depending on the response type) to extract and parse the body of the response.</p> <p>For example, to extract the JSON body, you would write:</p> javascript<pre><code>const post = await fetch(\"https://jsonplaceholder.typicode.com/posts/1\");\nconst postData = await post.json(); // This parses the response body as JSON\nconsole.log(postData);\n</code></pre> <p>Now, <code>console.log(postData)</code> would return something like:</p> <pre><code>{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\",\n  \"body\": \"quia et suscipit\\nsuscipit ...\"\n}\n</code></pre> Conclusion: <ul> <li> <p>The original <code>console.log(post)</code> just logs the <code>Response</code> object, which contains metadata about the response.</p> </li> <li> <p>To get the actual data (e.g., the post content), you need to parse the response with <code>.json()</code> or another method suitable for the response type.</p> </li> </ul> <ul> <li>javascript.info</li> </ul>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2025/03/30/understanding-cors-configurations-in-nodejs/","title":"Understanding CORS Configurations in Node.js","text":"<p>Cross-Origin Resource Sharing (CORS) is a mechanism that allows servers to specify who can access their resources from different origins. In this blog post, we'll explore why one CORS configuration works while another doesn't in a Node.js environment. ...</p>"},{"location":"blog/2025/03/30/understanding-cors-configurations-in-nodejs/#cors-configuration-explained","title":"CORS Configuration Explained","text":"<p>In a Node.js application, we use the <code>cors</code> middleware to handle CORS. Here are two common ways to configure it:</p>"},{"location":"blog/2025/03/30/understanding-cors-configurations-in-nodejs/#1-cors-configuration-that-works","title":"1. CORS Configuration That Works","text":"<pre><code>const corsOptions = {\n  origin: \"*\", // Allow all origins\n  methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"], // Allow specific methods\n  allowedHeaders: [\"Content-Type\", \"Authorization\"], // Allow specific headers\n};\n\napp.use(cors(corsOptions));\n</code></pre> Why It Works: <ul> <li> <p><code>origin: '*'</code>: Allows all origins to make requests to the server.</p> </li> <li> <p><code>methods: ['GET', 'POST', 'PUT', 'DELETE']</code>: This allows specific HTTP methods to be used in cross-origin requests. If the frontend needs to make a POST or PUT request, this configuration ensures that these methods are allowed.</p> </li> <li> <p><code>allowedHeaders: ['Content-Type', 'Authorization']</code>: This explicitly allows the <code>Content-Type</code> and <code>Authorization</code> headers in requests. Without this, browsers may reject requests that include custom headers.</p> </li> </ul> <p>This configuration works well for most applications, especially when the frontend needs to interact with the backend using custom methods or headers.</p>"},{"location":"blog/2025/03/30/understanding-cors-configurations-in-nodejs/#2-cors-configuration-that-might-not-work","title":"2. CORS Configuration That Might Not Work","text":"<pre><code>const corsOptions = {\n  origin: \"*\", // Allow all origins\n};\n\napp.use(cors(corsOptions));\n</code></pre> Why It Might Not Work: <ul> <li> <p><code>origin: '*'</code> allows requests from any origin, but that's not enough if the frontend is making requests using methods like POST, PUT, or custom headers like Authorization.</p> </li> <li> <p>Without specifying <code>methods</code> or <code>allowedHeaders</code>, the server may block requests that use these methods or custom headers because they are not explicitly allowed in the CORS configuration.</p> </li> </ul> <p>This configuration is more permissive but lacks the explicit allowance of headers and methods, which may lead to issues when using non-GET requests or custom headers.</p>"},{"location":"blog/2025/03/30/understanding-cors-configurations-in-nodejs/#conclusion","title":"Conclusion","text":"<p>In general, it's a good practice to be explicit with CORS configurations, especially when dealing with methods or custom headers. By specifying which methods and headers are allowed, you ensure that your API can handle a wider range of requests without being blocked by browsers due to CORS restrictions.</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/","title":"Debugging Cors Network Issue","text":"<p>If your Node.js API works in the web browser on your computer but not on the mobile browser, even when both devices are on the same network, let's go through a few more potential solutions and troubleshooting steps to fix this:</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#1-double-check-mobile-devices-network-connection","title":"1. Double-Check Mobile Device\u2019s Network Connection","text":"<p>Ensure that both devices are connected to the same Wi-Fi network. Sometimes, mobile devices may connect to a different network (like a 5G network) while the computer is connected to the local Wi-Fi network.</p> <p>You can verify this by checking the IP address on both devices. On your computer, verify the IP address with <code>ipconfig</code> (Windows) or <code>ifconfig</code> (Linux/macOS). On the mobile device, you can try to <code>ping</code> your computer\u2019s IP address (192.168.1.69) to ensure the network is properly connected.</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#2-confirm-ip-address","title":"2. Confirm IP Address","text":"<p>Since you mentioned that the server works on <code>http://192.168.1.69:3000</code> (in the browser on your computer), confirm that the correct IP address is being used in your mobile browser. Make sure you're using <code>http://192.168.1.69:5000</code> for the API.</p> <ul> <li> <p>If you are accessing <code>http://localhost:5000</code> or <code>http://127.0.0.1:5000</code> from the mobile browser, it won\u2019t work because those addresses refer to the mobile device itself, not the computer running the server.</p> </li> <li> <p>Use <code>http://192.168.1.69:5000/api/records</code> for testing the API from your mobile device.</p> </li> </ul>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#3-firewall-configuration-on-computer-server","title":"3. Firewall Configuration on Computer (Server)","text":"<p>If your server is on a computer and you cannot access it from your mobile device, there might be a firewall blocking external access to port <code>5000</code>. You need to ensure that the firewall is open on your computer for the API server to accept incoming requests from other devices.</p> <p>For Linux (iptables or firewalld):</p> <p>If you're using iptables, allow traffic on port <code>5000</code>:</p> <pre><code>sudo iptables -A INPUT -p tcp --dport 5000 -j ACCEPT\n</code></pre> <p>For firewalld, run:</p> <pre><code>sudo firewall-cmd --zone=public --add-port=5000/tcp --permanent\nsudo firewall-cmd --reload\n</code></pre> <p>For Windows:</p> <ol> <li>Open Windows Defender Firewall.</li> <li>Go to Advanced Settings &gt; Inbound Rules &gt; New Rule.</li> <li>Select Port and allow TCP for port <code>5000</code>.</li> <li>Ensure the rule is enabled.</li> </ol>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#4-cors-settings","title":"4. CORS Settings","text":"<p>Since your web app works on the computer but not on mobile, it could be a CORS issue. However, you\u2019ve already configured CORS using <code>origin: \"*\"</code>, which should be sufficient for all devices, including mobile. But sometimes mobile browsers might behave differently, so let\u2019s double-check:</p> <p>Try setting specific headers to ensure CORS is correctly enabled. You can configure it like this:</p> <pre><code>const corsOptions = {\n  origin: \"*\", // Allow all origins\n  methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"], // Allow specific methods\n  allowedHeaders: [\"Content-Type\", \"Authorization\"], // Allow specific headers\n};\n\napp.use(cors(corsOptions));\n</code></pre>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#5-test-using-curl-or-postman-on-mobile","title":"5. Test Using Curl or Postman on Mobile","text":"<p>Instead of using the browser, you can test the API on your mobile device using Postman or curl to see if the issue is with the mobile browser itself.</p> <p>Using Postman on Mobile:</p> <p>You can install Postman on your mobile device (available for both Android and iOS) and send a request to <code>http://192.168.1.69:5000/api/records</code>. If it works in Postman but not in the browser, it might be a browser-related issue, such as blocking CORS or mixed content.</p> <p>Using curl on Android (or iOS):</p> <p>You can use a terminal emulator app like Termux for Android or iSH Shell for iOS to make an HTTP request:</p> <pre><code>curl http://192.168.1.69:5000/api/records\n</code></pre>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#6-check-for-mixed-content-http-vs-https","title":"6. Check for Mixed Content (HTTP vs HTTPS)","text":"<p>If your mobile device is trying to access the API over HTTPS while your Node.js server is serving over HTTP, some mobile browsers may block the request because it's considered \"mixed content.\"</p> <p>Make sure your mobile browser is making requests to HTTP (not HTTPS) if you're not using SSL for your local development server. This could be a common issue in some mobile browsers, especially if you're using <code>http://</code> on the computer but <code>https://</code> on mobile.</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#7-verify-server-binding-on-0000","title":"7. Verify Server Binding on 0.0.0.0","text":"<p>You've already set the server to bind to <code>0.0.0.0</code>, which should make the server accessible from any device on the network:</p> <pre><code>app.listen(5000, \"0.0.0.0\", () =&gt; {\n  console.log(\"Server running on port 5000\");\n});\n</code></pre> <p>This is correct. It binds the server to all network interfaces, which ensures that requests from other devices (including your mobile device) can access the server.</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#8-mobile-browser-developer-tools","title":"8. Mobile Browser Developer Tools","text":"<p>Sometimes, there could be issues with the mobile browser's settings. You can try clearing the cache or opening the browser's developer tools (if available) to inspect the network requests and see what error is being returned (like a CORS error or network timeout).</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#9-test-api-using-localhost-vs-ip-address","title":"9. Test API Using <code>localhost</code> vs IP Address","text":"<p>If you're running the server on the same device as the browser (for instance, running both the client and server on your computer), <code>localhost:5000</code> will work. But when testing from another device (like your mobile), you need to use the IP address of your server (<code>192.168.1.69:5000</code>), not <code>localhost</code>.</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#10-server-logs","title":"10. Server Logs","text":"<p>Check the server logs to see if there are any requests coming from the mobile device. You can log the requests on the server to verify that it's receiving the API calls.</p> <pre><code>app.use((req, res, next) =&gt; {\n  console.log(`Request from: ${req.ip} for ${req.originalUrl}`);\n  next();\n});\n</code></pre> <p>This will log the incoming requests to your API, which might help diagnose if the mobile device's requests are being received at all.</p>"},{"location":"blog/2025/03/30/debugging-cors-network-issue/#recap","title":"Recap:","text":"<ul> <li>Network: Ensure both devices are on the same network.</li> <li>Firewall: Open port <code>5000</code> on the server machine if using a firewall.</li> <li>CORS: Double-check that CORS is configured correctly.</li> <li>Use correct IP: Make sure you're using <code>192.168.1.69:5000</code> on mobile.</li> <li>Mixed Content: Ensure you're not facing an HTTPS vs HTTP issue.</li> <li>Test with Postman/curl: Test the API using other tools on mobile to rule out browser issues.</li> </ul>"},{"location":"hosting/intro/","title":"Intro","text":"<p>Render.com</p> <p>Reddit: Free hosting for super lightweight node.js server?</p>"},{"location":"blog/archive/2025/","title":"2025","text":""}]}